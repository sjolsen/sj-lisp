;;;; Copyright Â© 2014 Stuart J. Olsen. See file "LICENSE."
;;;
;;;; Operations on lists. Where possible, both modifying and non-modifying
;;;; versions are given.
;;;
;;;; FIXME: SPLIT-LIST and NSPLIT-LIST take a non-negative FIXNUM as their
;;;; length argument. This improves the code generated by SBCL significantly,
;;;; but is it the right thing to do? (INTEGER 0 MOST-POSITIVE-FIXNUM) should
;;;; probably be given a proper name either way.

(in-package :sj-lisp)


;;;; Functions SPLIT-LIST, NSPLIT-LIST

;;; Given one list, return two freshly consed lists: a list containing the first
;;; N elements of LIST, and a list containing the rest of them. This is
;;; effectively the same as:
;;;
;;;    (VALUES (BUTLAST LIST (- (LENGTH LIST) N)
;;;            (COPY-LIST (LAST LIST (- (LENGTH LIST) N))))
;;;
;;; but a bit more efficient, visiting each cell exactly once. If the FROM-END
;;; argument is supplied and is non-NIL, it is equivalent to:
;;;
;;;    (VALUES (BUTLAST LIST N
;;;            (COPY-LIST (LAST LIST N)))
;;;
;;; but again, probably faster. See also NSPLIT-LIST.
(defun split-list (list &optional (n 1) from-end)
  "Split LIST at the supplied point, copying. See also NSPLIT-LIST."
  (declare (type list list)
           (type (integer 0 #.most-positive-fixnum) n))
  (let ((forward-n
         (if from-end
             (- (length list) n)
             n)))
    (loop
       for head-cursor on list
       repeat forward-n
       collecting (car head-cursor) into first-list
       finally (return (values first-list
                               (copy-list head-cursor))))))

;;; The mutating, non-consing version of SPLIT-LIST.
(defun nsplit-list (list &optional (n 1) from-end)
  "Mutatively split LIST at the supplied point. See also SPLIT-LIST."
  (declare (type list list)
           (type (integer 0 #.most-positive-fixnum) n))
  (let ((forward-n
         (if from-end
             (- (length list) n)
             n)))
    (if (zerop forward-n)
        (values list nil)
        (loop
           for head-cursor on list
           repeat (1- forward-n)
           finally (return (values list
                                   (exchangef (cdr head-cursor) nil)))))))
